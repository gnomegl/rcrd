#!/usr/bin/env bash

# @describe Screen recording tool with audio options
# @option -m --mic "Record microphone audio" @default "true"
# @option -s --system "Record system audio" @default "false"
# @option -o --output "Output filename (auto-generated if not specified)" [string]
# @option -q --quality "Video quality (ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow)" @default "medium"
# @option -r --fps "Frames per second" @default "30"
# @option --video-size "Video resolution (WIDTHxHEIGHT)" @default "1920x1080"
# @flag   --no-audio "Disable all audio recording"
# @flag   -v --verbose "Show verbose ffmpeg output"
# @meta require-tools ffmpeg

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    _argc_require_tools "${_argc_tools[@]}"
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
Screen recording tool with audio options

USAGE: rcrd [OPTIONS] <COMMAND>

OPTIONS:
  -m, --mic <MIC>                "Record microphone audio" @default "true"
  -s, --system <SYSTEM>          "Record system audio" @default "false"
  -o, --output <OUTPUT>          "Output filename (auto-generated if not specified)" [string]
  -q, --quality <QUALITY>        "Video quality (ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow)" @default "medium"
  -r, --fps <FPS>                "Frames per second" @default "30"
      --video-size <VIDEO-SIZE>  "Video resolution (WIDTHxHEIGHT)" @default "1920x1080"
      --no-audio                 "Disable all audio recording"
  -v, --verbose                  "Show verbose ffmpeg output"
  -h, --help                     Print help
  -V, --version                  Print version

COMMANDS:
  left        Record the left monitor
  right       Record the right monitor
  area        Record a specific area of the screen
  primary     Record the primary display (auto-detect)
  devices     List available audio devices
  test-audio  Test audio setup without recording
EOF
    exit
}

_argc_version() {
    echo rcrd 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds="left, right, area, primary, devices, test-audio"
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --mic | -m)
            _argc_take_args "--mic <MIC>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_mic:-}" ]]; then
                argc_mic="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--mic\` cannot be used multiple times"
            fi
            ;;
        --system | -s)
            _argc_take_args "--system <SYSTEM>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_system:-}" ]]; then
                argc_system="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--system\` cannot be used multiple times"
            fi
            ;;
        --output | -o)
            _argc_take_args "--output <OUTPUT>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_output:-}" ]]; then
                argc_output="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--output\` cannot be used multiple times"
            fi
            ;;
        --quality | -q)
            _argc_take_args "--quality <QUALITY>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_quality:-}" ]]; then
                argc_quality="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--quality\` cannot be used multiple times"
            fi
            ;;
        --fps | -r)
            _argc_take_args "--fps <FPS>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_fps:-}" ]]; then
                argc_fps="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--fps\` cannot be used multiple times"
            fi
            ;;
        --video-size)
            _argc_take_args "--video-size <VIDEO-SIZE>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_video_size:-}" ]]; then
                argc_video_size="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--video-size\` cannot be used multiple times"
            fi
            ;;
        --no-audio)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--no-audio\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_no_audio:-}" ]]; then
                _argc_die "error: the argument \`--no-audio\` cannot be used multiple times"
            else
                argc_no_audio=1
            fi
            ;;
        --verbose | -v)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--verbose\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_verbose:-}" ]]; then
                _argc_die "error: the argument \`--verbose\` cannot be used multiple times"
            else
                argc_verbose=1
            fi
            ;;
        left)
            _argc_index=$((_argc_index + 1))
            _argc_action=_argc_parse_left
            break
            ;;
        right)
            _argc_index=$((_argc_index + 1))
            _argc_action=_argc_parse_right
            break
            ;;
        area)
            _argc_index=$((_argc_index + 1))
            _argc_action=_argc_parse_area
            break
            ;;
        primary)
            _argc_index=$((_argc_index + 1))
            _argc_action=_argc_parse_primary
            break
            ;;
        devices)
            _argc_index=$((_argc_index + 1))
            _argc_action=_argc_parse_devices
            break
            ;;
        test-audio)
            _argc_index=$((_argc_index + 1))
            _argc_action=_argc_parse_test-audio
            break
            ;;
        help)
            local help_arg="${argc__args[$((_argc_index + 1))]:-}"
            case "$help_arg" in
            left)
                _argc_usage_left
                ;;
            right)
                _argc_usage_right
                ;;
            area)
                _argc_usage_area
                ;;
            primary)
                _argc_usage_primary
                ;;
            devices)
                _argc_usage_devices
                ;;
            test-audio)
                _argc_usage_test-audio
                ;;
            "")
                _argc_usage
                ;;
            *)
                _argc_die "error: invalid value \`$help_arg\` for \`<command>\`"$'\n'"  [possible values: $_argc_subcmds]"
                ;;
            esac
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            _argc_die "error: \`rcrd\` requires a subcommand but one was not provided"$'\n'"  [subcommands: $_argc_subcmds]"
            ;;
        esac
    done
    _argc_tools=(ffmpeg)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        _argc_usage
    fi
}

_argc_usage_left() {
    cat <<-'EOF'
Record the left monitor

USAGE: rcrd left [OPTIONS]

OPTIONS:
  -f, --fullscreen  "Record in fullscreen mode"
  -h, --help        Print help
EOF
    exit
}

_argc_parse_left() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage_left
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --fullscreen | -f)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--fullscreen\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_fullscreen:-}" ]]; then
                _argc_die "error: the argument \`--fullscreen\` cannot be used multiple times"
            else
                argc_fullscreen=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(ffmpeg)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=left
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage_left
        fi
    fi
}

_argc_usage_right() {
    cat <<-'EOF'
Record the right monitor

USAGE: rcrd right [OPTIONS]

OPTIONS:
  -f, --fullscreen  "Record in fullscreen mode"
  -h, --help        Print help
EOF
    exit
}

_argc_parse_right() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage_right
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --fullscreen | -f)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--fullscreen\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_fullscreen:-}" ]]; then
                _argc_die "error: the argument \`--fullscreen\` cannot be used multiple times"
            else
                argc_fullscreen=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(ffmpeg)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=right
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage_right
        fi
    fi
}

_argc_usage_area() {
    cat <<-'EOF'
Record a specific area of the screen

USAGE: rcrd area [X] [Y] [WIDTH] [HEIGHT]

ARGS:
  [X]       "X coordinate of the top-left corner" [int]
  [Y]       "Y coordinate of the top-left corner" [int]
  [WIDTH]   "Width of the recording area" [int]
  [HEIGHT]  "Height of the recording area" [int]
EOF
    exit
}

_argc_parse_area() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage_area
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        *)
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(ffmpeg)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=area
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage_area
        fi
        _argc_match_positionals 0 0 0 0
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_x="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[1]:-}"
        if [[ -n "$values_index" ]]; then
            argc_y="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[2]:-}"
        if [[ -n "$values_index" ]]; then
            argc_width="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[3]:-}"
        if [[ -n "$values_index" ]]; then
            argc_height="${argc__positionals[values_index]}"
        fi
    fi
}

_argc_usage_primary() {
    cat <<-'EOF'
Record the primary display (auto-detect)

USAGE: rcrd primary
EOF
    exit
}

_argc_parse_primary() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage_primary
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        *)
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(ffmpeg)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=primary
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage_primary
        fi
    fi
}

_argc_usage_devices() {
    cat <<-'EOF'
List available audio devices

USAGE: rcrd devices
EOF
    exit
}

_argc_parse_devices() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage_devices
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        *)
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(ffmpeg)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=devices
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage_devices
        fi
    fi
}

_argc_usage_test-audio() {
    cat <<-'EOF'
Test audio setup without recording

USAGE: rcrd test-audio
EOF
    exit
}

_argc_parse_test-audio() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage_test-audio
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        *)
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(ffmpeg)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=test-audio
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage_test-audio
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_require_tools() {
    local tool missing_tools=()
    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    if [[ "${#missing_tools[@]}" -gt 0 ]]; then
        echo "error: missing tools: ${missing_tools[*]}" >&2
        exit 1
    fi
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

setup_colors() {
  if [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    bold="" reset="" blue="" green="" yellow="" cyan="" red=""
  else
    bold=$(tput bold) reset=$(tput sgr0) blue=$(tput setaf 4) green=$(tput setaf 2)
    yellow=$(tput setaf 3) cyan=$(tput setaf 6) red=$(tput setaf 1)
  fi
}
setup_colors

generate_filename() {
  if [ -n "$argc_output" ]; then
    echo "$argc_output"
  else
    local timestamp=$(date +"%Y%m%d-%H%M%S")
    echo "recording-${timestamp}.mp4"
  fi
}

get_audio_device() {
  local device_type="$1"
  case "$device_type" in
  mic)
    pactl list sources short | grep -E "(input|mic)" | head -1 | cut -f2 || echo "default"
    ;;
  system)
    pactl list sinks short | grep -E "(output|speaker)" | head -1 | awk '{print $2".monitor"}' || echo "default.monitor"
    ;;
  esac
}

build_ffmpeg_command() {
  local display_offset="$1"
  local filename="$2"
  local cmd="ffmpeg"

  [ "$argc_verbose" != "1" ] && cmd="$cmd -loglevel warning"

  cmd="$cmd -f x11grab -video_size $argc_video_size -framerate $argc_fps -i $display_offset"

  if [ "$argc_no_audio" != "1" ]; then
    local audio_inputs=""
    local input_count=0

    if [ "$argc_mic" = "true" ]; then
      local mic_device=$(get_audio_device "mic")
      audio_inputs="$audio_inputs -f pulse -i $mic_device"
      input_count=$((input_count + 1))
    fi

    if [ "$argc_system" = "true" ]; then
      local system_device=$(get_audio_device "system")
      audio_inputs="$audio_inputs -f pulse -i $system_device"
      input_count=$((input_count + 1))
    fi

    if [ $input_count -gt 0 ]; then
      cmd="$cmd $audio_inputs"

      if [ $input_count -gt 1 ]; then
        cmd="$cmd -filter_complex amix=inputs=$input_count:duration=longest"
      fi
    fi
  fi

  cmd="$cmd -c:v libx264 -preset $argc_quality -pix_fmt yuv420p"
  cmd="$cmd $filename"

  echo "$cmd"
}

record_screen() {
  local display_offset="$1"
  local position_name="$2"
  local filename=$(generate_filename)

  printf "${bold}Recording %s screen...${reset}\n" "$position_name"
  printf "${cyan}Output:${reset} %s\n" "$filename"
  printf "${cyan}Resolution:${reset} %s @ %s fps\n" "$argc_video_size" "$argc_fps"
  printf "${cyan}Quality:${reset} %s\n" "$argc_quality"

  if [ "$argc_no_audio" = "1" ]; then
    printf "${yellow}Audio:${reset} Disabled\n"
  else
    printf "${cyan}Microphone:${reset} %s\n" "$argc_mic"
    printf "${cyan}System Audio:${reset} %s\n" "$argc_system"
  fi

  echo ""
  printf "${yellow}Press Ctrl+C to stop recording${reset}\n\n"

  local ffmpeg_cmd=$(build_ffmpeg_command "$display_offset" "$filename")

  if ! eval "$ffmpeg_cmd"; then
    printf "${red}Recording failed${reset}\n" >&2
    return 1
  fi

  printf "\n${green}Recording saved:${reset} %s\n" "$filename"
}

# @cmd Record the left monitor
# @flag -f --fullscreen "Record in fullscreen mode"
left() {
  local display_offset=":0.0"
  record_screen "$display_offset" "left"
}

# @cmd Record the right monitor
# @flag -f --fullscreen "Record in fullscreen mode"
right() {
  local display_offset=":0.0+1920,0"
  record_screen "$display_offset" "right"
}

# @cmd Record a specific area of the screen
# @arg x "X coordinate of the top-left corner" [int]
# @arg y "Y coordinate of the top-left corner" [int]
# @arg width "Width of the recording area" [int]
# @arg height "Height of the recording area" [int]
area() {
  local display_offset=":0.0+${argc_x},${argc_y}"
  local custom_size="${argc_width}x${argc_height}"
  local original_video_size="$argc_video_size"
  argc_video_size="$custom_size"

  record_screen "$display_offset" "custom area (${argc_width}x${argc_height})"

  argc_video_size="$original_video_size"
}

# @cmd Record the primary display (auto-detect)
primary() {
  local display_offset=":0.0"
  record_screen "$display_offset" "primary"
}

# @cmd List available audio devices
devices() {
  printf "${bold}Available Audio Sources:${reset}\n"
  printf "${cyan}Microphone sources:${reset}\n"
  pactl list sources short | grep -E "(input|mic)" | while read -r line; do
    printf "  %s\n" "$(echo "$line" | cut -f2)"
  done

  printf "\n${cyan}System audio sources:${reset}\n"
  pactl list sinks short | while read -r line; do
    printf "  %s.monitor\n" "$(echo "$line" | cut -f2)"
  done
}

# @cmd Test audio setup without recording
test-audio() {
  printf "${bold}Testing audio setup...${reset}\n"

  if [ "$argc_no_audio" = "1" ]; then
    printf "${yellow}Audio is disabled${reset}\n"
    return 0
  fi

  if [ "$argc_mic" = "true" ]; then
    local mic_device=$(get_audio_device "mic")
    printf "${cyan}Microphone device:${reset} %s\n" "$mic_device"
    if pactl list sources | grep -q "$mic_device"; then
      printf "${green}✓ Microphone available${reset}\n"
    else
      printf "${red}✗ Microphone not found${reset}\n"
    fi
  fi

  if [ "$argc_system" = "true" ]; then
    local system_device=$(get_audio_device "system")
    printf "${cyan}System audio device:${reset} %s\n" "$system_device"
    if pactl list sources | grep -q "$system_device"; then
      printf "${green}✓ System audio available${reset}\n"
    else
      printf "${red}✗ System audio not found${reset}\n"
    fi
  fi
}
